#!/usr/bin/env python3
"""
Check for new ballot measures without updating the database
Useful for monitoring changes before committing to updates
"""
import sys
import logging
import argparse
from pathlib import Path
from datetime import datetime
from typing import List, Dict

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from src.config import DB_PATH, DATA_DIR
from src.scrapers.ca_sos import CASOSScraper
from src.parsers.ceda import CEDAParser
from src.parsers.ncsl import NCSLParser
from src.database.operations import Database
from src.database.models import BallotMeasure

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def normalize_measure_data(data: dict) -> dict:
    """Normalize field names to match BallotMeasure model"""
    normalized = data.copy()
    
    # Field name mappings
    if 'source' in normalized:
        normalized['data_source'] = normalized.pop('source')
    
    if 'measure_text' in normalized and 'title' not in normalized:
        normalized['title'] = normalized.pop('measure_text')
    
    # Ensure required fields exist (will be generated by model)
    normalized.setdefault('fingerprint', '')
    normalized.setdefault('measure_fingerprint', '')
    normalized.setdefault('content_hash', '')
    
    # List of valid BallotMeasure fields
    valid_fields = {
        'fingerprint', 'measure_fingerprint', 'content_hash',
        'measure_id', 'measure_letter', 'year', 'state', 'county', 'jurisdiction',
        'title', 'description', 'ballot_question',
        'yes_votes', 'no_votes', 'total_votes', 'percent_yes', 'percent_no',
        'passed', 'pass_fail',
        'measure_type', 'topic_primary', 'topic_secondary', 'category_type', 'category_topic',
        'data_source', 'source_url', 'pdf_url',
        'has_summary', 'summary_title', 'summary_text',
        'election_type', 'election_date', 'decade', 'century',
        'created_at', 'updated_at', 'last_seen_at', 'update_count',
        'is_active', 'is_duplicate', 'duplicate_type', 'master_id', 'merged_from'
    }
    
    # Remove any fields not in the model
    filtered = {k: v for k, v in normalized.items() if k in valid_fields}
    
    return filtered


class UpdateChecker:
    """Check for updates across all data sources"""
    
    def __init__(self, db_path: Path):
        self.db = Database(db_path)
        self.new_measures = []
        self.updated_measures = []
        self.unchanged_count = 0
    
    def check_source(self, source_name: str, measures: List[Dict]) -> Dict:
        """Check a single data source for updates"""
        logger.info(f"Checking {source_name} for updates...")
        
        stats = {
            'source': source_name,
            'total_checked': len(measures),
            'new': 0,
            'potential_updates': 0,
            'unchanged': 0
        }
        
        for measure_data in measures:
            # Normalize the data before creating BallotMeasure
            normalized_data = normalize_measure_data(measure_data)
            
            # Create measure object to generate fingerprints
            measure = BallotMeasure(**normalized_data)
            
            # Check if exists in database
            existing = self.db.find_by_fingerprint(measure.fingerprint)
            
            if not existing:
                # Check for cross-source match
                cross_match = self.db.find_by_content_hash(measure.content_hash)
                
                if not cross_match or len(cross_match) == 0:
                    # Genuinely new measure
                    stats['new'] += 1
                    self.new_measures.append({
                        'source': source_name,
                        'measure': measure_data
                    })
                else:
                    # Potential update from different source
                    if self._has_new_data(measure_data, cross_match[0].to_dict()):
                        stats['potential_updates'] += 1
                        self.updated_measures.append({
                            'source': source_name,
                            'measure': measure_data,
                            'existing': cross_match[0].to_dict()
                        })
                    else:
                        stats['unchanged'] += 1
            else:
                # Check if has new data
                existing_dict = existing.to_dict()
                if self._has_new_data(measure_data, existing_dict):
                    stats['potential_updates'] += 1
                    self.updated_measures.append({
                        'source': source_name,
                        'measure': measure_data,
                        'existing': existing_dict
                    })
                else:
                    stats['unchanged'] += 1
        
        return stats
    
    def _has_new_data(self, new_measure: Dict, existing: Dict) -> bool:
        """Check if new measure has data that existing doesn't"""
        update_fields = [
            'summary_text', 'yes_votes', 'no_votes', 'percent_yes',
            'passed', 'pdf_url', 'description'
        ]
        
        for field in update_fields:
            new_value = new_measure.get(field)
            existing_value = existing.get(field)
            
            # If new has data that existing doesn't
            if new_value and not existing_value:
                return True
            
            # If values are different (and not both None)
            if new_value != existing_value and new_value is not None:
                return True
        
        return False
    
    def print_summary(self, stats_list: List[Dict]):
        """Print a formatted summary of findings"""
        print("\n" + "="*60)
        print("ðŸ“Š UPDATE CHECK SUMMARY")
        print("="*60)
        
        total_new = sum(s['new'] for s in stats_list)
        total_updates = sum(s['potential_updates'] for s in stats_list)
        total_unchanged = sum(s['unchanged'] for s in stats_list)
        
        # Per-source breakdown
        print("\nBy Source:")
        for stats in stats_list:
            print(f"\n{stats['source']}:")
            print(f"  Checked: {stats['total_checked']}")
            print(f"  New: {stats['new']}")
            print(f"  Updates: {stats['potential_updates']}")
            print(f"  Unchanged: {stats['unchanged']}")
        
        # Overall summary
        print("\n" + "-"*60)
        print(f"TOTAL NEW MEASURES: {total_new}")
        print(f"TOTAL POTENTIAL UPDATES: {total_updates}")
        print(f"TOTAL UNCHANGED: {total_unchanged}")
        
        # Show sample of new measures
        if self.new_measures:
            print("\nðŸ†• Sample of New Measures (first 5):")
            for item in self.new_measures[:5]:
                measure = item['measure']
                print(f"  â€¢ [{item['source']}] {measure.get('year', 'N/A')} - {measure.get('title', 'Unknown')[:60]}")
            
            if len(self.new_measures) > 5:
                print(f"  ... and {len(self.new_measures) - 5} more")
        
        # Show sample of updates
        if self.updated_measures:
            print("\nðŸ”„ Sample of Potential Updates (first 5):")
            for item in self.updated_measures[:5]:
                measure = item['measure']
                existing = item['existing']
                print(f"  â€¢ [{item['source']}] {measure.get('title', 'Unknown')[:60]}")
                
                # Show what's new
                new_fields = []
                if measure.get('summary_text') and not existing.get('summary_text'):
                    new_fields.append('summary')
                if measure.get('yes_votes') and not existing.get('yes_votes'):
                    new_fields.append('votes')
                if measure.get('pdf_url') and not existing.get('pdf_url'):
                    new_fields.append('PDF')
                
                if new_fields:
                    print(f"    New data: {', '.join(new_fields)}")
            
            if len(self.updated_measures) > 5:
                print(f"  ... and {len(self.updated_measures) - 5} more")


def main():
    """Main function for checking updates"""
    parser = argparse.ArgumentParser(description='Check for new ballot measures')
    parser.add_argument(
        '--sources',
        nargs='+',
        choices=['ca_sos', 'ceda', 'ncsl', 'all'],
        default=['ca_sos'],
        help='Data sources to check (default: ca_sos)'
    )
    parser.add_argument(
        '--json',
        action='store_true',
        help='Output results as JSON'
    )
    parser.add_argument(
        '--quiet',
        action='store_true',
        help='Minimal output'
    )
    
    args = parser.parse_args()
    
    try:
        # Initialize checker
        if not DB_PATH.exists():
            logger.error(f"Database not found at {DB_PATH}")
            logger.info("Run 'scripts/update_db.py' to create the database first")
            return 1
        
        checker = UpdateChecker(DB_PATH)
        stats_list = []
        
        # Determine which sources to check
        sources_to_check = args.sources if 'all' not in args.sources else ['ca_sos', 'ceda', 'ncsl']
        
        # Check each source
        for source in sources_to_check:
            if source == 'ca_sos':
                scraper = CASOSScraper()
                measures = scraper.scrape()
                stats = checker.check_source('CA SOS', measures)
                stats_list.append(stats)
            
            elif source == 'ceda':
                parser = CEDAParser(DATA_DIR)
                measures_objects = parser.parse_all_files()
                if measures_objects:
                    # Convert BallotMeasure objects to dicts
                    measures = [m.to_dict() for m in measures_objects]
                    stats = checker.check_source('CEDA', measures)
                    stats_list.append(stats)
            
            elif source == 'ncsl':
                parser = NCSLParser(DATA_DIR)
                measures = parser.parse()
                if measures:
                    stats = checker.check_source('NCSL', measures)
                    stats_list.append(stats)
        
        # Output results
        if args.json:
            import json
            output = {
                'timestamp': datetime.now().isoformat(),
                'sources_checked': [s['source'] for s in stats_list],
                'statistics': stats_list,
                'new_measures': len(checker.new_measures),
                'potential_updates': len(checker.updated_measures)
            }
            print(json.dumps(output, indent=2))
        elif not args.quiet:
            checker.print_summary(stats_list)
        else:
            # Minimal output for scripts
            total_new = sum(s['new'] for s in stats_list)
            total_updates = sum(s['potential_updates'] for s in stats_list)
            print(f"{total_new},{total_updates}")
        
        # Return success exit code (changed from returning 2 when updates found)
        if checker.new_measures or checker.updated_measures:
            return 0  # Success - updates available
        return 0  # Success - no updates
        
    except Exception as e:
        logger.error(f"Error checking for updates: {e}", exc_info=True)
        return 1


if __name__ == "__main__":
    sys.exit(main())